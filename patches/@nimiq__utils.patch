diff --git a/dist/albatross-policy/albatross-policy.cjs b/dist/albatross-policy/albatross-policy.cjs
index e25febcdd8bf06349aaab69e5bf8b150d58eba64..86904b2bc5f31d507bbf4d6aa8511c514a0311a8 100644
--- a/dist/albatross-policy/albatross-policy.cjs
+++ b/dist/albatross-policy/albatross-policy.cjs
@@ -1,73 +1,136 @@
 'use strict';
 
-const constants = require('../shared/utils.CGhj4cNk.cjs');
+const constants = require('../shared/utils.DML7ha_E.cjs');
 
-function epochAt(blockNumber) {
-  if (blockNumber <= constants.PROOF_OF_STAKE_MIGRATION_BLOCK) return 0;
-  const offset = blockNumber - constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
+const getMigrationBlock = (options = { network: "main-albatross" }) => {
+  if (options.migrationBlock !== undefined) return options.migrationBlock;
+  const isTestnet = options.network?.toLowerCase().includes("test");
+  return isTestnet ? constants.PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET : constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
+};
+function getMigrationBlockInfo({ network }) {
+  const migrationBlock = getMigrationBlock({ network });
+  const isTestnet = network?.toLowerCase().includes("test");
+  const date = isTestnet ? constants.PROOF_OF_STAKE_MIGRATION_DATE_TESTNET : constants.PROOF_OF_STAKE_MIGRATION_DATE;
+  const timestamp = Math.floor(date.getTime());
+  return { timestamp, date, migrationBlock };
+}
+function epochAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber <= migrationBlock) return 0;
+  const offset = blockNumber - migrationBlock;
   return Math.floor((offset + constants.BLOCKS_PER_EPOCH - 1) / constants.BLOCKS_PER_EPOCH);
 }
-function epochIndexAt(blockNumber) {
-  if (blockNumber < constants.PROOF_OF_STAKE_MIGRATION_BLOCK) return blockNumber;
-  return (blockNumber - constants.PROOF_OF_STAKE_MIGRATION_BLOCK) % constants.BLOCKS_PER_EPOCH;
+function epochIndexAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return blockNumber;
+  return (blockNumber - migrationBlock + constants.BLOCKS_PER_EPOCH - 1) % constants.BLOCKS_PER_EPOCH;
 }
-function batchAt(blockNumber) {
-  if (blockNumber <= constants.PROOF_OF_STAKE_MIGRATION_BLOCK) return 0;
-  const offset = blockNumber - constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
+function batchAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber <= migrationBlock) return 0;
+  const offset = blockNumber - migrationBlock;
   return Math.floor((offset + constants.BLOCKS_PER_BATCH - 1) / constants.BLOCKS_PER_BATCH);
 }
-function batchIndexAt(blockNumber) {
-  if (blockNumber < constants.PROOF_OF_STAKE_MIGRATION_BLOCK) return blockNumber;
-  return (blockNumber - constants.PROOF_OF_STAKE_MIGRATION_BLOCK) % constants.BLOCKS_PER_BATCH;
-}
-function isMacroBlockAt(blockNumber) {
-  if (blockNumber < constants.PROOF_OF_STAKE_MIGRATION_BLOCK) return false;
-  return batchIndexAt(blockNumber) === constants.BLOCKS_PER_BATCH - 1;
-}
-function isElectionBlockAt(blockNumber) {
-  return epochIndexAt(blockNumber) === constants.BLOCKS_PER_EPOCH - 1;
-}
-function isMicroBlockAt(blockNumber) {
-  if (blockNumber < constants.PROOF_OF_STAKE_MIGRATION_BLOCK) return false;
-  return !isMacroBlockAt(blockNumber);
-}
-function macroBlockAfter(blockNumber) {
-  if (blockNumber < constants.PROOF_OF_STAKE_MIGRATION_BLOCK) return constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
-  const offset = blockNumber - constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
-  return (Math.floor(offset / constants.BLOCKS_PER_BATCH) + 1) * constants.BLOCKS_PER_BATCH + constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
-}
-function lastMacroBlock(blockNumber) {
-  if (blockNumber < constants.PROOF_OF_STAKE_MIGRATION_BLOCK) throw new Error("No macro blocks before genesis");
-  const offset = blockNumber - constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
-  return Math.floor(offset / constants.BLOCKS_PER_BATCH) * constants.BLOCKS_PER_BATCH + constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
-}
-function electionBlockAfter(blockNumber) {
-  if (blockNumber < constants.PROOF_OF_STAKE_MIGRATION_BLOCK) return constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
-  const offset = blockNumber - constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
-  return (Math.floor(offset / constants.BLOCKS_PER_EPOCH) + 1) * constants.BLOCKS_PER_EPOCH + constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
-}
-function firstBlockOf(epoch) {
+function batchIndexAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return blockNumber;
+  return (blockNumber - migrationBlock + constants.BLOCKS_PER_BATCH - 1) % constants.BLOCKS_PER_BATCH;
+}
+function isMacroBlockAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return false;
+  return batchIndexAt(blockNumber, options) === constants.BLOCKS_PER_BATCH - 1;
+}
+function isElectionBlockAt(blockNumber, options = {}) {
+  return epochIndexAt(blockNumber, options) === constants.BLOCKS_PER_EPOCH - 1;
+}
+function isMicroBlockAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return false;
+  return !isMacroBlockAt(blockNumber, options);
+}
+function macroBlockAfter(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return migrationBlock;
+  const offset = blockNumber - migrationBlock;
+  const batchCount = Math.floor(offset / constants.BLOCKS_PER_BATCH) + 1;
+  const mulResult = batchCount * constants.BLOCKS_PER_BATCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + migrationBlock;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
+}
+function lastMacroBlock(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) throw new Error("No macro blocks before proof-of-stake migration");
+  const offset = blockNumber - migrationBlock;
+  const batchCount = Math.floor(offset / constants.BLOCKS_PER_BATCH);
+  const mulResult = batchCount * constants.BLOCKS_PER_BATCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + migrationBlock;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
+}
+function electionBlockAfter(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return migrationBlock;
+  const offset = blockNumber - migrationBlock;
+  const epochCount = Math.floor(offset / constants.BLOCKS_PER_EPOCH) + 1;
+  const mulResult = epochCount * constants.BLOCKS_PER_EPOCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + migrationBlock;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
+}
+function firstBlockOf(epoch, options = {}) {
   if (epoch <= 0) return undefined;
-  return (epoch - 1) * constants.BLOCKS_PER_EPOCH + constants.PROOF_OF_STAKE_MIGRATION_BLOCK + 1;
+  const migrationBlock = getMigrationBlock(options);
+  const subResult = epoch - 1;
+  if (!Number.isSafeInteger(subResult)) return undefined;
+  const mulResult = subResult * constants.BLOCKS_PER_EPOCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + migrationBlock + 1;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
 function blockAfterJail(blockNumber) {
-  return blockNumber + constants.BLOCKS_PER_EPOCH * constants.JAIL_EPOCHS + 1;
+  const mulResult = constants.BLOCKS_PER_EPOCH * constants.JAIL_EPOCHS;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = blockNumber + mulResult + 1;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
-function electionBlockOf(epoch) {
+function electionBlockOf(epoch, options = {}) {
   if (epoch < 0) return undefined;
-  return constants.PROOF_OF_STAKE_MIGRATION_BLOCK + (epoch + 1) * constants.BLOCKS_PER_EPOCH - 1;
+  const genesisBlock = getMigrationBlock(options);
+  const mulResult = epoch * constants.BLOCKS_PER_EPOCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + genesisBlock;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
 function batchDelayPenalty(delayMs) {
-  return (1 - constants.MINIMUM_REWARDS_PERCENTAGE) * (constants.BLOCKS_DELAY_DECAY ** delayMs) ** delayMs + constants.MINIMUM_REWARDS_PERCENTAGE;
+  if (!Number.isSafeInteger(delayMs) || delayMs < 0) {
+    return constants.MINIMUM_REWARDS_PERCENTAGE;
+  }
+  const decayPower = constants.BLOCKS_DELAY_DECAY ** delayMs;
+  const finalDecay = decayPower ** delayMs;
+  return (1 - constants.MINIMUM_REWARDS_PERCENTAGE) * finalDecay + constants.MINIMUM_REWARDS_PERCENTAGE;
 }
-function firstBatchOfEpoch(blockNumber) {
-  return epochIndexAt(blockNumber) < constants.BLOCKS_PER_BATCH;
+function firstBatchOfEpoch(blockNumber, options = {}) {
+  return epochIndexAt(blockNumber, options) < constants.BLOCKS_PER_BATCH;
 }
 function lastBlockOfReportingWindow(blockNumber) {
-  return blockNumber + constants.BLOCKS_PER_EPOCH;
+  const addResult = blockNumber + constants.BLOCKS_PER_EPOCH;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
 function blockAfterReportingWindow(blockNumber) {
-  return lastBlockOfReportingWindow(blockNumber) + 1;
+  const lastBlock = lastBlockOfReportingWindow(blockNumber);
+  if (lastBlock === undefined) return undefined;
+  const addResult = lastBlock + 1;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
 
 exports.BATCHES_PER_EPOCH = constants.BATCHES_PER_EPOCH;
@@ -92,7 +155,9 @@ exports.MIN_EPOCHS_STORED = constants.MIN_EPOCHS_STORED;
 exports.MIN_PRODUCER_TIMEOUT = constants.MIN_PRODUCER_TIMEOUT;
 exports.POS_DECAY_PER_DAY = constants.POS_DECAY_PER_DAY;
 exports.PROOF_OF_STAKE_MIGRATION_BLOCK = constants.PROOF_OF_STAKE_MIGRATION_BLOCK;
+exports.PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET = constants.PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET;
 exports.PROOF_OF_STAKE_MIGRATION_DATE = constants.PROOF_OF_STAKE_MIGRATION_DATE;
+exports.PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = constants.PROOF_OF_STAKE_MIGRATION_DATE_TESTNET;
 exports.PROOF_OF_WORK_EMISSION_SPEED = constants.PROOF_OF_WORK_EMISSION_SPEED;
 exports.PROOF_OF_WORK_EMISSION_TAIL_REWARD = constants.PROOF_OF_WORK_EMISSION_TAIL_REWARD;
 exports.PROOF_OF_WORK_EMISSION_TAIL_START = constants.PROOF_OF_WORK_EMISSION_TAIL_START;
@@ -123,6 +188,7 @@ exports.epochAt = epochAt;
 exports.epochIndexAt = epochIndexAt;
 exports.firstBatchOfEpoch = firstBatchOfEpoch;
 exports.firstBlockOf = firstBlockOf;
+exports.getMigrationBlockInfo = getMigrationBlockInfo;
 exports.isElectionBlockAt = isElectionBlockAt;
 exports.isMacroBlockAt = isMacroBlockAt;
 exports.isMicroBlockAt = isMicroBlockAt;
diff --git a/dist/albatross-policy/albatross-policy.d.cts b/dist/albatross-policy/albatross-policy.d.cts
index 01b02e457969be256167a5023e823eba0ccbbb1e..5e52b359d4a5ef3774b7223744312f2dc3662444 100644
--- a/dist/albatross-policy/albatross-policy.d.cts
+++ b/dist/albatross-policy/albatross-policy.d.cts
@@ -6,6 +6,10 @@ declare const TOTAL_SUPPLY = 2100000000000000;
  * The date of the proof-of-stake migration.
  */
 declare const PROOF_OF_STAKE_MIGRATION_DATE: Date;
+/**
+ * The date of the proof-of-stake migration in **Testnet**.
+ */
+declare const PROOF_OF_STAKE_MIGRATION_DATE_TESTNET: Date;
 /**
  * The total supply of the cryptocurrency at the proof-of-stake migration date, in NIM.
  *
@@ -24,6 +28,10 @@ declare const SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = 12030755339.5289
  * The block height of the proof-of-stake migration.
  */
 declare const PROOF_OF_STAKE_MIGRATION_BLOCK = 3456000;
+/**
+ * The block height of the proof-of-stake migration in **Testnet**.
+ */
+declare const PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET = 3032010;
 /**
  * The initial supply of the cryptocurrency, in Lunas.
  */
@@ -74,58 +82,80 @@ declare const TRANSACTION_VALIDITY_WINDOW_BLOCKS: number;
 declare const STAKING_CONTRACT_ADDRESS = "NQ77 0000 0000 0000 0000 0000 0000 0000 0001";
 declare const COINBASE_ADDRESS = "NQ81 C01N BASE 0000 0000 0000 0000 0000 0000";
 
+interface BaseAlbatrossPolicyOptions {
+    /**
+     * Whether to use the testnet block height for proof-of-stake migration.
+     * Can be a boolean or a string containing 'test' to use testnet values.
+     * @default 'main-albatross'
+     */
+    network?: string;
+    /**
+     * Custom migration block to use instead of the default.
+     */
+    migrationBlock?: number;
+}
+/**
+ * Returns information about the migration block based on the network.
+ */
+declare function getMigrationBlockInfo({ network }: Pick<BaseAlbatrossPolicyOptions, 'network'>): {
+    timestamp: number;
+    date: Date;
+    migrationBlock: number;
+};
 /**
  * Returns the epoch number for a given block number.
  */
-declare function epochAt(blockNumber: number): number;
+declare function epochAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the epoch index for a given block number.
+ * Adjusted to add BLOCKS_PER_EPOCH - 1 before taking the modulo.
  */
-declare function epochIndexAt(blockNumber: number): number;
+declare function epochIndexAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the batch number for a given block number.
  */
-declare function batchAt(blockNumber: number): number;
+declare function batchAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the batch index for a given block number.
+ * Adjusted to add BLOCKS_PER_BATCH - 1 before taking the modulo.
  */
-declare function batchIndexAt(blockNumber: number): number;
+declare function batchIndexAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Checks if a given block number is a macro block.
  */
-declare function isMacroBlockAt(blockNumber: number): boolean;
+declare function isMacroBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Checks if a given block number is an election block.
  */
-declare function isElectionBlockAt(blockNumber: number): boolean;
+declare function isElectionBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Checks if a given block number is a micro block.
  */
-declare function isMicroBlockAt(blockNumber: number): boolean;
+declare function isMicroBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Returns the next macro block number after the given block number.
  */
-declare function macroBlockAfter(blockNumber: number): number;
+declare function macroBlockAfter(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the last macro block number before the given block number.
  */
-declare function lastMacroBlock(blockNumber: number): number;
+declare function lastMacroBlock(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the next election block number after the given block number.
  */
-declare function electionBlockAfter(blockNumber: number): number;
+declare function electionBlockAfter(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the first block number of the given epoch.
  */
-declare function firstBlockOf(epoch: number): number | undefined;
+declare function firstBlockOf(epoch: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the block number after the jail period.
  */
-declare function blockAfterJail(blockNumber: number): number;
+declare function blockAfterJail(blockNumber: number): number | undefined;
 /**
  * Returns the election block number for a given epoch.
  */
-declare function electionBlockOf(epoch: number): number | undefined;
+declare function electionBlockOf(epoch: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Calculates rewards penalty due to batch delay.
  */
@@ -133,14 +163,14 @@ declare function batchDelayPenalty(delayMs: number): number;
 /**
  * Returns true if the block number is the first batch of an epoch.
  */
-declare function firstBatchOfEpoch(blockNumber: number): boolean;
+declare function firstBatchOfEpoch(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Returns the last block number of the reporting window for a given block number.
  */
-declare function lastBlockOfReportingWindow(blockNumber: number): number;
+declare function lastBlockOfReportingWindow(blockNumber: number): number | undefined;
 /**
  * Returns the block number immediately after the reporting window for a given block number.
  */
-declare function blockAfterReportingWindow(blockNumber: number): number;
+declare function blockAfterReportingWindow(blockNumber: number): number | undefined;
 
-export { BATCHES_PER_EPOCH, BLOCKS_DELAY_DECAY, BLOCKS_PER_BATCH, BLOCKS_PER_EPOCH, BLOCK_SEPARATION_TIME, BLS_CACHE_MAX_CAPACITY, COINBASE_ADDRESS, F_PLUS_ONE, HISTORY_CHUNKS_MAX_SIZE, JAIL_EPOCHS, MAX_BASIC_TX_RECIPIENT_DATA_SIZE, MAX_MERKLE_PATH_SIZE, MAX_SIZE_MICRO_BODY, MAX_SUPPORTED_WEB_AUTH_SIZE, MAX_TX_RECIPIENT_DATA_SIZE, MAX_TX_SENDER_DATA_SIZE, MINIMUM_REWARDS_PERCENTAGE, MINIMUM_STAKE, MIN_EPOCHS_STORED, MIN_PRODUCER_TIMEOUT, POS_DECAY_PER_DAY, PROOF_OF_STAKE_MIGRATION_BLOCK, PROOF_OF_STAKE_MIGRATION_DATE, PROOF_OF_WORK_EMISSION_SPEED, PROOF_OF_WORK_EMISSION_TAIL_REWARD, PROOF_OF_WORK_EMISSION_TAIL_START, PROOF_OF_WORK_INITIAL_SUPPLY, SLOTS, STAKING_CONTRACT_ADDRESS, STATE_CHUNKS_MAX_SIZE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, SUPPLY_DECAY, TENDERMINT_TIMEOUT_DELTA, TENDERMINT_TIMEOUT_INIT, TIMESTAMP_MAX_DRIFT, TOTAL_SUPPLY, TRANSACTION_VALIDITY_WINDOW, TRANSACTION_VALIDITY_WINDOW_BLOCKS, TWO_F_PLUS_ONE, VALIDATOR_DEPOSIT, VERSION, batchAt, batchDelayPenalty, batchIndexAt, blockAfterJail, blockAfterReportingWindow, electionBlockAfter, electionBlockOf, epochAt, epochIndexAt, firstBatchOfEpoch, firstBlockOf, isElectionBlockAt, isMacroBlockAt, isMicroBlockAt, lastBlockOfReportingWindow, lastMacroBlock, macroBlockAfter };
+export { BATCHES_PER_EPOCH, BLOCKS_DELAY_DECAY, BLOCKS_PER_BATCH, BLOCKS_PER_EPOCH, BLOCK_SEPARATION_TIME, BLS_CACHE_MAX_CAPACITY, type BaseAlbatrossPolicyOptions, COINBASE_ADDRESS, F_PLUS_ONE, HISTORY_CHUNKS_MAX_SIZE, JAIL_EPOCHS, MAX_BASIC_TX_RECIPIENT_DATA_SIZE, MAX_MERKLE_PATH_SIZE, MAX_SIZE_MICRO_BODY, MAX_SUPPORTED_WEB_AUTH_SIZE, MAX_TX_RECIPIENT_DATA_SIZE, MAX_TX_SENDER_DATA_SIZE, MINIMUM_REWARDS_PERCENTAGE, MINIMUM_STAKE, MIN_EPOCHS_STORED, MIN_PRODUCER_TIMEOUT, POS_DECAY_PER_DAY, PROOF_OF_STAKE_MIGRATION_BLOCK, PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET, PROOF_OF_STAKE_MIGRATION_DATE, PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, PROOF_OF_WORK_EMISSION_SPEED, PROOF_OF_WORK_EMISSION_TAIL_REWARD, PROOF_OF_WORK_EMISSION_TAIL_START, PROOF_OF_WORK_INITIAL_SUPPLY, SLOTS, STAKING_CONTRACT_ADDRESS, STATE_CHUNKS_MAX_SIZE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, SUPPLY_DECAY, TENDERMINT_TIMEOUT_DELTA, TENDERMINT_TIMEOUT_INIT, TIMESTAMP_MAX_DRIFT, TOTAL_SUPPLY, TRANSACTION_VALIDITY_WINDOW, TRANSACTION_VALIDITY_WINDOW_BLOCKS, TWO_F_PLUS_ONE, VALIDATOR_DEPOSIT, VERSION, batchAt, batchDelayPenalty, batchIndexAt, blockAfterJail, blockAfterReportingWindow, electionBlockAfter, electionBlockOf, epochAt, epochIndexAt, firstBatchOfEpoch, firstBlockOf, getMigrationBlockInfo, isElectionBlockAt, isMacroBlockAt, isMicroBlockAt, lastBlockOfReportingWindow, lastMacroBlock, macroBlockAfter };
diff --git a/dist/albatross-policy/albatross-policy.d.mts b/dist/albatross-policy/albatross-policy.d.mts
index 01b02e457969be256167a5023e823eba0ccbbb1e..5e52b359d4a5ef3774b7223744312f2dc3662444 100644
--- a/dist/albatross-policy/albatross-policy.d.mts
+++ b/dist/albatross-policy/albatross-policy.d.mts
@@ -6,6 +6,10 @@ declare const TOTAL_SUPPLY = 2100000000000000;
  * The date of the proof-of-stake migration.
  */
 declare const PROOF_OF_STAKE_MIGRATION_DATE: Date;
+/**
+ * The date of the proof-of-stake migration in **Testnet**.
+ */
+declare const PROOF_OF_STAKE_MIGRATION_DATE_TESTNET: Date;
 /**
  * The total supply of the cryptocurrency at the proof-of-stake migration date, in NIM.
  *
@@ -24,6 +28,10 @@ declare const SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = 12030755339.5289
  * The block height of the proof-of-stake migration.
  */
 declare const PROOF_OF_STAKE_MIGRATION_BLOCK = 3456000;
+/**
+ * The block height of the proof-of-stake migration in **Testnet**.
+ */
+declare const PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET = 3032010;
 /**
  * The initial supply of the cryptocurrency, in Lunas.
  */
@@ -74,58 +82,80 @@ declare const TRANSACTION_VALIDITY_WINDOW_BLOCKS: number;
 declare const STAKING_CONTRACT_ADDRESS = "NQ77 0000 0000 0000 0000 0000 0000 0000 0001";
 declare const COINBASE_ADDRESS = "NQ81 C01N BASE 0000 0000 0000 0000 0000 0000";
 
+interface BaseAlbatrossPolicyOptions {
+    /**
+     * Whether to use the testnet block height for proof-of-stake migration.
+     * Can be a boolean or a string containing 'test' to use testnet values.
+     * @default 'main-albatross'
+     */
+    network?: string;
+    /**
+     * Custom migration block to use instead of the default.
+     */
+    migrationBlock?: number;
+}
+/**
+ * Returns information about the migration block based on the network.
+ */
+declare function getMigrationBlockInfo({ network }: Pick<BaseAlbatrossPolicyOptions, 'network'>): {
+    timestamp: number;
+    date: Date;
+    migrationBlock: number;
+};
 /**
  * Returns the epoch number for a given block number.
  */
-declare function epochAt(blockNumber: number): number;
+declare function epochAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the epoch index for a given block number.
+ * Adjusted to add BLOCKS_PER_EPOCH - 1 before taking the modulo.
  */
-declare function epochIndexAt(blockNumber: number): number;
+declare function epochIndexAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the batch number for a given block number.
  */
-declare function batchAt(blockNumber: number): number;
+declare function batchAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the batch index for a given block number.
+ * Adjusted to add BLOCKS_PER_BATCH - 1 before taking the modulo.
  */
-declare function batchIndexAt(blockNumber: number): number;
+declare function batchIndexAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Checks if a given block number is a macro block.
  */
-declare function isMacroBlockAt(blockNumber: number): boolean;
+declare function isMacroBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Checks if a given block number is an election block.
  */
-declare function isElectionBlockAt(blockNumber: number): boolean;
+declare function isElectionBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Checks if a given block number is a micro block.
  */
-declare function isMicroBlockAt(blockNumber: number): boolean;
+declare function isMicroBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Returns the next macro block number after the given block number.
  */
-declare function macroBlockAfter(blockNumber: number): number;
+declare function macroBlockAfter(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the last macro block number before the given block number.
  */
-declare function lastMacroBlock(blockNumber: number): number;
+declare function lastMacroBlock(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the next election block number after the given block number.
  */
-declare function electionBlockAfter(blockNumber: number): number;
+declare function electionBlockAfter(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the first block number of the given epoch.
  */
-declare function firstBlockOf(epoch: number): number | undefined;
+declare function firstBlockOf(epoch: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the block number after the jail period.
  */
-declare function blockAfterJail(blockNumber: number): number;
+declare function blockAfterJail(blockNumber: number): number | undefined;
 /**
  * Returns the election block number for a given epoch.
  */
-declare function electionBlockOf(epoch: number): number | undefined;
+declare function electionBlockOf(epoch: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Calculates rewards penalty due to batch delay.
  */
@@ -133,14 +163,14 @@ declare function batchDelayPenalty(delayMs: number): number;
 /**
  * Returns true if the block number is the first batch of an epoch.
  */
-declare function firstBatchOfEpoch(blockNumber: number): boolean;
+declare function firstBatchOfEpoch(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Returns the last block number of the reporting window for a given block number.
  */
-declare function lastBlockOfReportingWindow(blockNumber: number): number;
+declare function lastBlockOfReportingWindow(blockNumber: number): number | undefined;
 /**
  * Returns the block number immediately after the reporting window for a given block number.
  */
-declare function blockAfterReportingWindow(blockNumber: number): number;
+declare function blockAfterReportingWindow(blockNumber: number): number | undefined;
 
-export { BATCHES_PER_EPOCH, BLOCKS_DELAY_DECAY, BLOCKS_PER_BATCH, BLOCKS_PER_EPOCH, BLOCK_SEPARATION_TIME, BLS_CACHE_MAX_CAPACITY, COINBASE_ADDRESS, F_PLUS_ONE, HISTORY_CHUNKS_MAX_SIZE, JAIL_EPOCHS, MAX_BASIC_TX_RECIPIENT_DATA_SIZE, MAX_MERKLE_PATH_SIZE, MAX_SIZE_MICRO_BODY, MAX_SUPPORTED_WEB_AUTH_SIZE, MAX_TX_RECIPIENT_DATA_SIZE, MAX_TX_SENDER_DATA_SIZE, MINIMUM_REWARDS_PERCENTAGE, MINIMUM_STAKE, MIN_EPOCHS_STORED, MIN_PRODUCER_TIMEOUT, POS_DECAY_PER_DAY, PROOF_OF_STAKE_MIGRATION_BLOCK, PROOF_OF_STAKE_MIGRATION_DATE, PROOF_OF_WORK_EMISSION_SPEED, PROOF_OF_WORK_EMISSION_TAIL_REWARD, PROOF_OF_WORK_EMISSION_TAIL_START, PROOF_OF_WORK_INITIAL_SUPPLY, SLOTS, STAKING_CONTRACT_ADDRESS, STATE_CHUNKS_MAX_SIZE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, SUPPLY_DECAY, TENDERMINT_TIMEOUT_DELTA, TENDERMINT_TIMEOUT_INIT, TIMESTAMP_MAX_DRIFT, TOTAL_SUPPLY, TRANSACTION_VALIDITY_WINDOW, TRANSACTION_VALIDITY_WINDOW_BLOCKS, TWO_F_PLUS_ONE, VALIDATOR_DEPOSIT, VERSION, batchAt, batchDelayPenalty, batchIndexAt, blockAfterJail, blockAfterReportingWindow, electionBlockAfter, electionBlockOf, epochAt, epochIndexAt, firstBatchOfEpoch, firstBlockOf, isElectionBlockAt, isMacroBlockAt, isMicroBlockAt, lastBlockOfReportingWindow, lastMacroBlock, macroBlockAfter };
+export { BATCHES_PER_EPOCH, BLOCKS_DELAY_DECAY, BLOCKS_PER_BATCH, BLOCKS_PER_EPOCH, BLOCK_SEPARATION_TIME, BLS_CACHE_MAX_CAPACITY, type BaseAlbatrossPolicyOptions, COINBASE_ADDRESS, F_PLUS_ONE, HISTORY_CHUNKS_MAX_SIZE, JAIL_EPOCHS, MAX_BASIC_TX_RECIPIENT_DATA_SIZE, MAX_MERKLE_PATH_SIZE, MAX_SIZE_MICRO_BODY, MAX_SUPPORTED_WEB_AUTH_SIZE, MAX_TX_RECIPIENT_DATA_SIZE, MAX_TX_SENDER_DATA_SIZE, MINIMUM_REWARDS_PERCENTAGE, MINIMUM_STAKE, MIN_EPOCHS_STORED, MIN_PRODUCER_TIMEOUT, POS_DECAY_PER_DAY, PROOF_OF_STAKE_MIGRATION_BLOCK, PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET, PROOF_OF_STAKE_MIGRATION_DATE, PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, PROOF_OF_WORK_EMISSION_SPEED, PROOF_OF_WORK_EMISSION_TAIL_REWARD, PROOF_OF_WORK_EMISSION_TAIL_START, PROOF_OF_WORK_INITIAL_SUPPLY, SLOTS, STAKING_CONTRACT_ADDRESS, STATE_CHUNKS_MAX_SIZE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, SUPPLY_DECAY, TENDERMINT_TIMEOUT_DELTA, TENDERMINT_TIMEOUT_INIT, TIMESTAMP_MAX_DRIFT, TOTAL_SUPPLY, TRANSACTION_VALIDITY_WINDOW, TRANSACTION_VALIDITY_WINDOW_BLOCKS, TWO_F_PLUS_ONE, VALIDATOR_DEPOSIT, VERSION, batchAt, batchDelayPenalty, batchIndexAt, blockAfterJail, blockAfterReportingWindow, electionBlockAfter, electionBlockOf, epochAt, epochIndexAt, firstBatchOfEpoch, firstBlockOf, getMigrationBlockInfo, isElectionBlockAt, isMacroBlockAt, isMicroBlockAt, lastBlockOfReportingWindow, lastMacroBlock, macroBlockAfter };
diff --git a/dist/albatross-policy/albatross-policy.d.ts b/dist/albatross-policy/albatross-policy.d.ts
index 01b02e457969be256167a5023e823eba0ccbbb1e..5e52b359d4a5ef3774b7223744312f2dc3662444 100644
--- a/dist/albatross-policy/albatross-policy.d.ts
+++ b/dist/albatross-policy/albatross-policy.d.ts
@@ -6,6 +6,10 @@ declare const TOTAL_SUPPLY = 2100000000000000;
  * The date of the proof-of-stake migration.
  */
 declare const PROOF_OF_STAKE_MIGRATION_DATE: Date;
+/**
+ * The date of the proof-of-stake migration in **Testnet**.
+ */
+declare const PROOF_OF_STAKE_MIGRATION_DATE_TESTNET: Date;
 /**
  * The total supply of the cryptocurrency at the proof-of-stake migration date, in NIM.
  *
@@ -24,6 +28,10 @@ declare const SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = 12030755339.5289
  * The block height of the proof-of-stake migration.
  */
 declare const PROOF_OF_STAKE_MIGRATION_BLOCK = 3456000;
+/**
+ * The block height of the proof-of-stake migration in **Testnet**.
+ */
+declare const PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET = 3032010;
 /**
  * The initial supply of the cryptocurrency, in Lunas.
  */
@@ -74,58 +82,80 @@ declare const TRANSACTION_VALIDITY_WINDOW_BLOCKS: number;
 declare const STAKING_CONTRACT_ADDRESS = "NQ77 0000 0000 0000 0000 0000 0000 0000 0001";
 declare const COINBASE_ADDRESS = "NQ81 C01N BASE 0000 0000 0000 0000 0000 0000";
 
+interface BaseAlbatrossPolicyOptions {
+    /**
+     * Whether to use the testnet block height for proof-of-stake migration.
+     * Can be a boolean or a string containing 'test' to use testnet values.
+     * @default 'main-albatross'
+     */
+    network?: string;
+    /**
+     * Custom migration block to use instead of the default.
+     */
+    migrationBlock?: number;
+}
+/**
+ * Returns information about the migration block based on the network.
+ */
+declare function getMigrationBlockInfo({ network }: Pick<BaseAlbatrossPolicyOptions, 'network'>): {
+    timestamp: number;
+    date: Date;
+    migrationBlock: number;
+};
 /**
  * Returns the epoch number for a given block number.
  */
-declare function epochAt(blockNumber: number): number;
+declare function epochAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the epoch index for a given block number.
+ * Adjusted to add BLOCKS_PER_EPOCH - 1 before taking the modulo.
  */
-declare function epochIndexAt(blockNumber: number): number;
+declare function epochIndexAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the batch number for a given block number.
  */
-declare function batchAt(blockNumber: number): number;
+declare function batchAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Returns the batch index for a given block number.
+ * Adjusted to add BLOCKS_PER_BATCH - 1 before taking the modulo.
  */
-declare function batchIndexAt(blockNumber: number): number;
+declare function batchIndexAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number;
 /**
  * Checks if a given block number is a macro block.
  */
-declare function isMacroBlockAt(blockNumber: number): boolean;
+declare function isMacroBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Checks if a given block number is an election block.
  */
-declare function isElectionBlockAt(blockNumber: number): boolean;
+declare function isElectionBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Checks if a given block number is a micro block.
  */
-declare function isMicroBlockAt(blockNumber: number): boolean;
+declare function isMicroBlockAt(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Returns the next macro block number after the given block number.
  */
-declare function macroBlockAfter(blockNumber: number): number;
+declare function macroBlockAfter(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the last macro block number before the given block number.
  */
-declare function lastMacroBlock(blockNumber: number): number;
+declare function lastMacroBlock(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the next election block number after the given block number.
  */
-declare function electionBlockAfter(blockNumber: number): number;
+declare function electionBlockAfter(blockNumber: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the first block number of the given epoch.
  */
-declare function firstBlockOf(epoch: number): number | undefined;
+declare function firstBlockOf(epoch: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Returns the block number after the jail period.
  */
-declare function blockAfterJail(blockNumber: number): number;
+declare function blockAfterJail(blockNumber: number): number | undefined;
 /**
  * Returns the election block number for a given epoch.
  */
-declare function electionBlockOf(epoch: number): number | undefined;
+declare function electionBlockOf(epoch: number, options?: BaseAlbatrossPolicyOptions): number | undefined;
 /**
  * Calculates rewards penalty due to batch delay.
  */
@@ -133,14 +163,14 @@ declare function batchDelayPenalty(delayMs: number): number;
 /**
  * Returns true if the block number is the first batch of an epoch.
  */
-declare function firstBatchOfEpoch(blockNumber: number): boolean;
+declare function firstBatchOfEpoch(blockNumber: number, options?: BaseAlbatrossPolicyOptions): boolean;
 /**
  * Returns the last block number of the reporting window for a given block number.
  */
-declare function lastBlockOfReportingWindow(blockNumber: number): number;
+declare function lastBlockOfReportingWindow(blockNumber: number): number | undefined;
 /**
  * Returns the block number immediately after the reporting window for a given block number.
  */
-declare function blockAfterReportingWindow(blockNumber: number): number;
+declare function blockAfterReportingWindow(blockNumber: number): number | undefined;
 
-export { BATCHES_PER_EPOCH, BLOCKS_DELAY_DECAY, BLOCKS_PER_BATCH, BLOCKS_PER_EPOCH, BLOCK_SEPARATION_TIME, BLS_CACHE_MAX_CAPACITY, COINBASE_ADDRESS, F_PLUS_ONE, HISTORY_CHUNKS_MAX_SIZE, JAIL_EPOCHS, MAX_BASIC_TX_RECIPIENT_DATA_SIZE, MAX_MERKLE_PATH_SIZE, MAX_SIZE_MICRO_BODY, MAX_SUPPORTED_WEB_AUTH_SIZE, MAX_TX_RECIPIENT_DATA_SIZE, MAX_TX_SENDER_DATA_SIZE, MINIMUM_REWARDS_PERCENTAGE, MINIMUM_STAKE, MIN_EPOCHS_STORED, MIN_PRODUCER_TIMEOUT, POS_DECAY_PER_DAY, PROOF_OF_STAKE_MIGRATION_BLOCK, PROOF_OF_STAKE_MIGRATION_DATE, PROOF_OF_WORK_EMISSION_SPEED, PROOF_OF_WORK_EMISSION_TAIL_REWARD, PROOF_OF_WORK_EMISSION_TAIL_START, PROOF_OF_WORK_INITIAL_SUPPLY, SLOTS, STAKING_CONTRACT_ADDRESS, STATE_CHUNKS_MAX_SIZE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, SUPPLY_DECAY, TENDERMINT_TIMEOUT_DELTA, TENDERMINT_TIMEOUT_INIT, TIMESTAMP_MAX_DRIFT, TOTAL_SUPPLY, TRANSACTION_VALIDITY_WINDOW, TRANSACTION_VALIDITY_WINDOW_BLOCKS, TWO_F_PLUS_ONE, VALIDATOR_DEPOSIT, VERSION, batchAt, batchDelayPenalty, batchIndexAt, blockAfterJail, blockAfterReportingWindow, electionBlockAfter, electionBlockOf, epochAt, epochIndexAt, firstBatchOfEpoch, firstBlockOf, isElectionBlockAt, isMacroBlockAt, isMicroBlockAt, lastBlockOfReportingWindow, lastMacroBlock, macroBlockAfter };
+export { BATCHES_PER_EPOCH, BLOCKS_DELAY_DECAY, BLOCKS_PER_BATCH, BLOCKS_PER_EPOCH, BLOCK_SEPARATION_TIME, BLS_CACHE_MAX_CAPACITY, type BaseAlbatrossPolicyOptions, COINBASE_ADDRESS, F_PLUS_ONE, HISTORY_CHUNKS_MAX_SIZE, JAIL_EPOCHS, MAX_BASIC_TX_RECIPIENT_DATA_SIZE, MAX_MERKLE_PATH_SIZE, MAX_SIZE_MICRO_BODY, MAX_SUPPORTED_WEB_AUTH_SIZE, MAX_TX_RECIPIENT_DATA_SIZE, MAX_TX_SENDER_DATA_SIZE, MINIMUM_REWARDS_PERCENTAGE, MINIMUM_STAKE, MIN_EPOCHS_STORED, MIN_PRODUCER_TIMEOUT, POS_DECAY_PER_DAY, PROOF_OF_STAKE_MIGRATION_BLOCK, PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET, PROOF_OF_STAKE_MIGRATION_DATE, PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, PROOF_OF_WORK_EMISSION_SPEED, PROOF_OF_WORK_EMISSION_TAIL_REWARD, PROOF_OF_WORK_EMISSION_TAIL_START, PROOF_OF_WORK_INITIAL_SUPPLY, SLOTS, STAKING_CONTRACT_ADDRESS, STATE_CHUNKS_MAX_SIZE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, SUPPLY_DECAY, TENDERMINT_TIMEOUT_DELTA, TENDERMINT_TIMEOUT_INIT, TIMESTAMP_MAX_DRIFT, TOTAL_SUPPLY, TRANSACTION_VALIDITY_WINDOW, TRANSACTION_VALIDITY_WINDOW_BLOCKS, TWO_F_PLUS_ONE, VALIDATOR_DEPOSIT, VERSION, batchAt, batchDelayPenalty, batchIndexAt, blockAfterJail, blockAfterReportingWindow, electionBlockAfter, electionBlockOf, epochAt, epochIndexAt, firstBatchOfEpoch, firstBlockOf, getMigrationBlockInfo, isElectionBlockAt, isMacroBlockAt, isMicroBlockAt, lastBlockOfReportingWindow, lastMacroBlock, macroBlockAfter };
diff --git a/dist/albatross-policy/albatross-policy.mjs b/dist/albatross-policy/albatross-policy.mjs
index 741f246981bf8dc758a3d0baf122357d4cedfc60..f7d332994ee473ecac71367f63b6e915c05f27b6 100644
--- a/dist/albatross-policy/albatross-policy.mjs
+++ b/dist/albatross-policy/albatross-policy.mjs
@@ -1,72 +1,135 @@
-import { c as PROOF_OF_STAKE_MIGRATION_BLOCK, B as BLOCKS_PER_EPOCH, d as BLOCKS_PER_BATCH, J as JAIL_EPOCHS, M as MINIMUM_REWARDS_PERCENTAGE, e as BLOCKS_DELAY_DECAY } from '../shared/utils.CviVNm85.mjs';
-export { C as BATCHES_PER_EPOCH, s as BLOCK_SEPARATION_TIME, A as BLS_CACHE_MAX_CAPACITY, K as COINBASE_ADDRESS, F as F_PLUS_ONE, H as HISTORY_CHUNKS_MAX_SIZE, m as MAX_BASIC_TX_RECIPIENT_DATA_SIZE, n as MAX_MERKLE_PATH_SIZE, j as MAX_SIZE_MICRO_BODY, o as MAX_SUPPORTED_WEB_AUTH_SIZE, l as MAX_TX_RECIPIENT_DATA_SIZE, k as MAX_TX_SENDER_DATA_SIZE, y as MINIMUM_STAKE, v as MIN_EPOCHS_STORED, r as MIN_PRODUCER_TIMEOUT, b as POS_DECAY_PER_DAY, P as PROOF_OF_STAKE_MIGRATION_DATE, g as PROOF_OF_WORK_EMISSION_SPEED, i as PROOF_OF_WORK_EMISSION_TAIL_REWARD, h as PROOF_OF_WORK_EMISSION_TAIL_START, f as PROOF_OF_WORK_INITIAL_SUPPLY, p as SLOTS, I as STAKING_CONTRACT_ADDRESS, D as STATE_CHUNKS_MAX_SIZE, a as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, S as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, z as SUPPLY_DECAY, u as TENDERMINT_TIMEOUT_DELTA, t as TENDERMINT_TIMEOUT_INIT, w as TIMESTAMP_MAX_DRIFT, T as TOTAL_SUPPLY, E as TRANSACTION_VALIDITY_WINDOW, G as TRANSACTION_VALIDITY_WINDOW_BLOCKS, q as TWO_F_PLUS_ONE, x as VALIDATOR_DEPOSIT, V as VERSION } from '../shared/utils.CviVNm85.mjs';
+import { c as PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, P as PROOF_OF_STAKE_MIGRATION_DATE, B as BLOCKS_PER_EPOCH, d as BLOCKS_PER_BATCH, M as MINIMUM_REWARDS_PERCENTAGE, e as PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET, f as PROOF_OF_STAKE_MIGRATION_BLOCK, J as JAIL_EPOCHS, g as BLOCKS_DELAY_DECAY } from '../shared/utils.BWNGyNU1.mjs';
+export { E as BATCHES_PER_EPOCH, u as BLOCK_SEPARATION_TIME, D as BLS_CACHE_MAX_CAPACITY, N as COINBASE_ADDRESS, F as F_PLUS_ONE, H as HISTORY_CHUNKS_MAX_SIZE, o as MAX_BASIC_TX_RECIPIENT_DATA_SIZE, p as MAX_MERKLE_PATH_SIZE, l as MAX_SIZE_MICRO_BODY, q as MAX_SUPPORTED_WEB_AUTH_SIZE, n as MAX_TX_RECIPIENT_DATA_SIZE, m as MAX_TX_SENDER_DATA_SIZE, A as MINIMUM_STAKE, x as MIN_EPOCHS_STORED, t as MIN_PRODUCER_TIMEOUT, b as POS_DECAY_PER_DAY, i as PROOF_OF_WORK_EMISSION_SPEED, k as PROOF_OF_WORK_EMISSION_TAIL_REWARD, j as PROOF_OF_WORK_EMISSION_TAIL_START, h as PROOF_OF_WORK_INITIAL_SUPPLY, r as SLOTS, L as STAKING_CONTRACT_ADDRESS, G as STATE_CHUNKS_MAX_SIZE, a as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, S as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, C as SUPPLY_DECAY, w as TENDERMINT_TIMEOUT_DELTA, v as TENDERMINT_TIMEOUT_INIT, y as TIMESTAMP_MAX_DRIFT, T as TOTAL_SUPPLY, I as TRANSACTION_VALIDITY_WINDOW, K as TRANSACTION_VALIDITY_WINDOW_BLOCKS, s as TWO_F_PLUS_ONE, z as VALIDATOR_DEPOSIT, V as VERSION } from '../shared/utils.BWNGyNU1.mjs';
 
-function epochAt(blockNumber) {
-  if (blockNumber <= PROOF_OF_STAKE_MIGRATION_BLOCK) return 0;
-  const offset = blockNumber - PROOF_OF_STAKE_MIGRATION_BLOCK;
+const getMigrationBlock = (options = { network: "main-albatross" }) => {
+  if (options.migrationBlock !== undefined) return options.migrationBlock;
+  const isTestnet = options.network?.toLowerCase().includes("test");
+  return isTestnet ? PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET : PROOF_OF_STAKE_MIGRATION_BLOCK;
+};
+function getMigrationBlockInfo({ network }) {
+  const migrationBlock = getMigrationBlock({ network });
+  const isTestnet = network?.toLowerCase().includes("test");
+  const date = isTestnet ? PROOF_OF_STAKE_MIGRATION_DATE_TESTNET : PROOF_OF_STAKE_MIGRATION_DATE;
+  const timestamp = Math.floor(date.getTime());
+  return { timestamp, date, migrationBlock };
+}
+function epochAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber <= migrationBlock) return 0;
+  const offset = blockNumber - migrationBlock;
   return Math.floor((offset + BLOCKS_PER_EPOCH - 1) / BLOCKS_PER_EPOCH);
 }
-function epochIndexAt(blockNumber) {
-  if (blockNumber < PROOF_OF_STAKE_MIGRATION_BLOCK) return blockNumber;
-  return (blockNumber - PROOF_OF_STAKE_MIGRATION_BLOCK) % BLOCKS_PER_EPOCH;
+function epochIndexAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return blockNumber;
+  return (blockNumber - migrationBlock + BLOCKS_PER_EPOCH - 1) % BLOCKS_PER_EPOCH;
 }
-function batchAt(blockNumber) {
-  if (blockNumber <= PROOF_OF_STAKE_MIGRATION_BLOCK) return 0;
-  const offset = blockNumber - PROOF_OF_STAKE_MIGRATION_BLOCK;
+function batchAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber <= migrationBlock) return 0;
+  const offset = blockNumber - migrationBlock;
   return Math.floor((offset + BLOCKS_PER_BATCH - 1) / BLOCKS_PER_BATCH);
 }
-function batchIndexAt(blockNumber) {
-  if (blockNumber < PROOF_OF_STAKE_MIGRATION_BLOCK) return blockNumber;
-  return (blockNumber - PROOF_OF_STAKE_MIGRATION_BLOCK) % BLOCKS_PER_BATCH;
-}
-function isMacroBlockAt(blockNumber) {
-  if (blockNumber < PROOF_OF_STAKE_MIGRATION_BLOCK) return false;
-  return batchIndexAt(blockNumber) === BLOCKS_PER_BATCH - 1;
-}
-function isElectionBlockAt(blockNumber) {
-  return epochIndexAt(blockNumber) === BLOCKS_PER_EPOCH - 1;
-}
-function isMicroBlockAt(blockNumber) {
-  if (blockNumber < PROOF_OF_STAKE_MIGRATION_BLOCK) return false;
-  return !isMacroBlockAt(blockNumber);
-}
-function macroBlockAfter(blockNumber) {
-  if (blockNumber < PROOF_OF_STAKE_MIGRATION_BLOCK) return PROOF_OF_STAKE_MIGRATION_BLOCK;
-  const offset = blockNumber - PROOF_OF_STAKE_MIGRATION_BLOCK;
-  return (Math.floor(offset / BLOCKS_PER_BATCH) + 1) * BLOCKS_PER_BATCH + PROOF_OF_STAKE_MIGRATION_BLOCK;
-}
-function lastMacroBlock(blockNumber) {
-  if (blockNumber < PROOF_OF_STAKE_MIGRATION_BLOCK) throw new Error("No macro blocks before genesis");
-  const offset = blockNumber - PROOF_OF_STAKE_MIGRATION_BLOCK;
-  return Math.floor(offset / BLOCKS_PER_BATCH) * BLOCKS_PER_BATCH + PROOF_OF_STAKE_MIGRATION_BLOCK;
-}
-function electionBlockAfter(blockNumber) {
-  if (blockNumber < PROOF_OF_STAKE_MIGRATION_BLOCK) return PROOF_OF_STAKE_MIGRATION_BLOCK;
-  const offset = blockNumber - PROOF_OF_STAKE_MIGRATION_BLOCK;
-  return (Math.floor(offset / BLOCKS_PER_EPOCH) + 1) * BLOCKS_PER_EPOCH + PROOF_OF_STAKE_MIGRATION_BLOCK;
-}
-function firstBlockOf(epoch) {
+function batchIndexAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return blockNumber;
+  return (blockNumber - migrationBlock + BLOCKS_PER_BATCH - 1) % BLOCKS_PER_BATCH;
+}
+function isMacroBlockAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return false;
+  return batchIndexAt(blockNumber, options) === BLOCKS_PER_BATCH - 1;
+}
+function isElectionBlockAt(blockNumber, options = {}) {
+  return epochIndexAt(blockNumber, options) === BLOCKS_PER_EPOCH - 1;
+}
+function isMicroBlockAt(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return false;
+  return !isMacroBlockAt(blockNumber, options);
+}
+function macroBlockAfter(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return migrationBlock;
+  const offset = blockNumber - migrationBlock;
+  const batchCount = Math.floor(offset / BLOCKS_PER_BATCH) + 1;
+  const mulResult = batchCount * BLOCKS_PER_BATCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + migrationBlock;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
+}
+function lastMacroBlock(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) throw new Error("No macro blocks before proof-of-stake migration");
+  const offset = blockNumber - migrationBlock;
+  const batchCount = Math.floor(offset / BLOCKS_PER_BATCH);
+  const mulResult = batchCount * BLOCKS_PER_BATCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + migrationBlock;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
+}
+function electionBlockAfter(blockNumber, options = {}) {
+  const migrationBlock = getMigrationBlock(options);
+  if (blockNumber < migrationBlock) return migrationBlock;
+  const offset = blockNumber - migrationBlock;
+  const epochCount = Math.floor(offset / BLOCKS_PER_EPOCH) + 1;
+  const mulResult = epochCount * BLOCKS_PER_EPOCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + migrationBlock;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
+}
+function firstBlockOf(epoch, options = {}) {
   if (epoch <= 0) return undefined;
-  return (epoch - 1) * BLOCKS_PER_EPOCH + PROOF_OF_STAKE_MIGRATION_BLOCK + 1;
+  const migrationBlock = getMigrationBlock(options);
+  const subResult = epoch - 1;
+  if (!Number.isSafeInteger(subResult)) return undefined;
+  const mulResult = subResult * BLOCKS_PER_EPOCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + migrationBlock + 1;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
 function blockAfterJail(blockNumber) {
-  return blockNumber + BLOCKS_PER_EPOCH * JAIL_EPOCHS + 1;
+  const mulResult = BLOCKS_PER_EPOCH * JAIL_EPOCHS;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = blockNumber + mulResult + 1;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
-function electionBlockOf(epoch) {
+function electionBlockOf(epoch, options = {}) {
   if (epoch < 0) return undefined;
-  return PROOF_OF_STAKE_MIGRATION_BLOCK + (epoch + 1) * BLOCKS_PER_EPOCH - 1;
+  const genesisBlock = getMigrationBlock(options);
+  const mulResult = epoch * BLOCKS_PER_EPOCH;
+  if (!Number.isSafeInteger(mulResult)) return undefined;
+  const addResult = mulResult + genesisBlock;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
 function batchDelayPenalty(delayMs) {
-  return (1 - MINIMUM_REWARDS_PERCENTAGE) * (BLOCKS_DELAY_DECAY ** delayMs) ** delayMs + MINIMUM_REWARDS_PERCENTAGE;
+  if (!Number.isSafeInteger(delayMs) || delayMs < 0) {
+    return MINIMUM_REWARDS_PERCENTAGE;
+  }
+  const decayPower = BLOCKS_DELAY_DECAY ** delayMs;
+  const finalDecay = decayPower ** delayMs;
+  return (1 - MINIMUM_REWARDS_PERCENTAGE) * finalDecay + MINIMUM_REWARDS_PERCENTAGE;
 }
-function firstBatchOfEpoch(blockNumber) {
-  return epochIndexAt(blockNumber) < BLOCKS_PER_BATCH;
+function firstBatchOfEpoch(blockNumber, options = {}) {
+  return epochIndexAt(blockNumber, options) < BLOCKS_PER_BATCH;
 }
 function lastBlockOfReportingWindow(blockNumber) {
-  return blockNumber + BLOCKS_PER_EPOCH;
+  const addResult = blockNumber + BLOCKS_PER_EPOCH;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
 function blockAfterReportingWindow(blockNumber) {
-  return lastBlockOfReportingWindow(blockNumber) + 1;
+  const lastBlock = lastBlockOfReportingWindow(blockNumber);
+  if (lastBlock === undefined) return undefined;
+  const addResult = lastBlock + 1;
+  if (!Number.isSafeInteger(addResult)) return undefined;
+  return addResult;
 }
 
-export { BLOCKS_DELAY_DECAY, BLOCKS_PER_BATCH, BLOCKS_PER_EPOCH, JAIL_EPOCHS, MINIMUM_REWARDS_PERCENTAGE, PROOF_OF_STAKE_MIGRATION_BLOCK, batchAt, batchDelayPenalty, batchIndexAt, blockAfterJail, blockAfterReportingWindow, electionBlockAfter, electionBlockOf, epochAt, epochIndexAt, firstBatchOfEpoch, firstBlockOf, isElectionBlockAt, isMacroBlockAt, isMicroBlockAt, lastBlockOfReportingWindow, lastMacroBlock, macroBlockAfter };
+export { BLOCKS_DELAY_DECAY, BLOCKS_PER_BATCH, BLOCKS_PER_EPOCH, JAIL_EPOCHS, MINIMUM_REWARDS_PERCENTAGE, PROOF_OF_STAKE_MIGRATION_BLOCK, PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET, PROOF_OF_STAKE_MIGRATION_DATE, PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, batchAt, batchDelayPenalty, batchIndexAt, blockAfterJail, blockAfterReportingWindow, electionBlockAfter, electionBlockOf, epochAt, epochIndexAt, firstBatchOfEpoch, firstBlockOf, getMigrationBlockInfo, isElectionBlockAt, isMacroBlockAt, isMicroBlockAt, lastBlockOfReportingWindow, lastMacroBlock, macroBlockAfter };
diff --git a/dist/rewards-calculator/rewards-calculator.cjs b/dist/rewards-calculator/rewards-calculator.cjs
index 577767cca983b5c98725fc552cb019f69c6b6af6..0cb0a9d35c35b668dd3507b7ba9b18923bc2c8e3 100644
--- a/dist/rewards-calculator/rewards-calculator.cjs
+++ b/dist/rewards-calculator/rewards-calculator.cjs
@@ -1,7 +1,7 @@
 'use strict';
 
-const pos = require('../shared/utils.C10-CJz4.cjs');
-const constants = require('../shared/utils.CGhj4cNk.cjs');
+const pos = require('../shared/utils.WuzDKwXp.cjs');
+const constants = require('../shared/utils.DML7ha_E.cjs');
 
 function calculateStakingRewards(params) {
   const {
diff --git a/dist/rewards-calculator/rewards-calculator.mjs b/dist/rewards-calculator/rewards-calculator.mjs
index 1f26d038a984003d26198f0d89844228c25c49b2..69e06f767854d5154903f59c70ce38e9038f07dc 100644
--- a/dist/rewards-calculator/rewards-calculator.mjs
+++ b/dist/rewards-calculator/rewards-calculator.mjs
@@ -1,5 +1,5 @@
-import { p as posSupplyAt } from '../shared/utils.CsKOXHuy.mjs';
-import { P as PROOF_OF_STAKE_MIGRATION_DATE, S as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, a as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, b as POS_DECAY_PER_DAY } from '../shared/utils.CviVNm85.mjs';
+import { p as posSupplyAt } from '../shared/utils.CZGg_TXP.mjs';
+import { P as PROOF_OF_STAKE_MIGRATION_DATE, S as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, a as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, b as POS_DECAY_PER_DAY } from '../shared/utils.BWNGyNU1.mjs';
 
 function calculateStakingRewards(params) {
   const {
diff --git a/dist/shared/utils.CviVNm85.mjs b/dist/shared/utils.BWNGyNU1.mjs
similarity index 55%
rename from dist/shared/utils.CviVNm85.mjs
rename to dist/shared/utils.BWNGyNU1.mjs
index 9fd61e7cd9f6747e16381cfb85f17df0848d93b8..5e4e43c6c9078b3446c2bbd68b2ecdb6b6740916 100644
--- a/dist/shared/utils.CviVNm85.mjs
+++ b/dist/shared/utils.BWNGyNU1.mjs
@@ -1,8 +1,10 @@
 const TOTAL_SUPPLY = 21e14;
-const PROOF_OF_STAKE_MIGRATION_DATE = /* @__PURE__ */ new Date("2024-11-19");
+const PROOF_OF_STAKE_MIGRATION_DATE = /* @__PURE__ */ new Date("2024-11-19T16:45:20.000Z");
+const PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = /* @__PURE__ */ new Date("2024-11-13T20:00:00.000Z");
 const SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE = 1289310965406244e-5;
 const SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = 1203075533952899e-5;
 const PROOF_OF_STAKE_MIGRATION_BLOCK = 3456e3;
+const PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET = 3032010;
 const PROOF_OF_WORK_INITIAL_SUPPLY = 252e12;
 const PROOF_OF_WORK_EMISSION_SPEED = 4194304;
 const PROOF_OF_WORK_EMISSION_TAIL_START = 48692960;
@@ -41,4 +43,4 @@ const TRANSACTION_VALIDITY_WINDOW_BLOCKS = TRANSACTION_VALIDITY_WINDOW * BLOCKS_
 const STAKING_CONTRACT_ADDRESS = "NQ77 0000 0000 0000 0000 0000 0000 0000 0001";
 const COINBASE_ADDRESS = "NQ81 C01N BASE 0000 0000 0000 0000 0000 0000";
 
-export { BLS_CACHE_MAX_CAPACITY as A, BLOCKS_PER_EPOCH as B, BATCHES_PER_EPOCH as C, STATE_CHUNKS_MAX_SIZE as D, TRANSACTION_VALIDITY_WINDOW as E, F_PLUS_ONE as F, TRANSACTION_VALIDITY_WINDOW_BLOCKS as G, HISTORY_CHUNKS_MAX_SIZE as H, STAKING_CONTRACT_ADDRESS as I, JAIL_EPOCHS as J, COINBASE_ADDRESS as K, MINIMUM_REWARDS_PERCENTAGE as M, PROOF_OF_STAKE_MIGRATION_DATE as P, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET as S, TOTAL_SUPPLY as T, VERSION as V, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE as a, POS_DECAY_PER_DAY as b, PROOF_OF_STAKE_MIGRATION_BLOCK as c, BLOCKS_PER_BATCH as d, BLOCKS_DELAY_DECAY as e, PROOF_OF_WORK_INITIAL_SUPPLY as f, PROOF_OF_WORK_EMISSION_SPEED as g, PROOF_OF_WORK_EMISSION_TAIL_START as h, PROOF_OF_WORK_EMISSION_TAIL_REWARD as i, MAX_SIZE_MICRO_BODY as j, MAX_TX_SENDER_DATA_SIZE as k, MAX_TX_RECIPIENT_DATA_SIZE as l, MAX_BASIC_TX_RECIPIENT_DATA_SIZE as m, MAX_MERKLE_PATH_SIZE as n, MAX_SUPPORTED_WEB_AUTH_SIZE as o, SLOTS as p, TWO_F_PLUS_ONE as q, MIN_PRODUCER_TIMEOUT as r, BLOCK_SEPARATION_TIME as s, TENDERMINT_TIMEOUT_INIT as t, TENDERMINT_TIMEOUT_DELTA as u, MIN_EPOCHS_STORED as v, TIMESTAMP_MAX_DRIFT as w, VALIDATOR_DEPOSIT as x, MINIMUM_STAKE as y, SUPPLY_DECAY as z };
+export { MINIMUM_STAKE as A, BLOCKS_PER_EPOCH as B, SUPPLY_DECAY as C, BLS_CACHE_MAX_CAPACITY as D, BATCHES_PER_EPOCH as E, F_PLUS_ONE as F, STATE_CHUNKS_MAX_SIZE as G, HISTORY_CHUNKS_MAX_SIZE as H, TRANSACTION_VALIDITY_WINDOW as I, JAIL_EPOCHS as J, TRANSACTION_VALIDITY_WINDOW_BLOCKS as K, STAKING_CONTRACT_ADDRESS as L, MINIMUM_REWARDS_PERCENTAGE as M, COINBASE_ADDRESS as N, PROOF_OF_STAKE_MIGRATION_DATE as P, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET as S, TOTAL_SUPPLY as T, VERSION as V, SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE as a, POS_DECAY_PER_DAY as b, PROOF_OF_STAKE_MIGRATION_DATE_TESTNET as c, BLOCKS_PER_BATCH as d, PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET as e, PROOF_OF_STAKE_MIGRATION_BLOCK as f, BLOCKS_DELAY_DECAY as g, PROOF_OF_WORK_INITIAL_SUPPLY as h, PROOF_OF_WORK_EMISSION_SPEED as i, PROOF_OF_WORK_EMISSION_TAIL_START as j, PROOF_OF_WORK_EMISSION_TAIL_REWARD as k, MAX_SIZE_MICRO_BODY as l, MAX_TX_SENDER_DATA_SIZE as m, MAX_TX_RECIPIENT_DATA_SIZE as n, MAX_BASIC_TX_RECIPIENT_DATA_SIZE as o, MAX_MERKLE_PATH_SIZE as p, MAX_SUPPORTED_WEB_AUTH_SIZE as q, SLOTS as r, TWO_F_PLUS_ONE as s, MIN_PRODUCER_TIMEOUT as t, BLOCK_SEPARATION_TIME as u, TENDERMINT_TIMEOUT_INIT as v, TENDERMINT_TIMEOUT_DELTA as w, MIN_EPOCHS_STORED as x, TIMESTAMP_MAX_DRIFT as y, VALIDATOR_DEPOSIT as z };
diff --git a/dist/shared/utils.CsKOXHuy.mjs b/dist/shared/utils.CZGg_TXP.mjs
similarity index 91%
rename from dist/shared/utils.CsKOXHuy.mjs
rename to dist/shared/utils.CZGg_TXP.mjs
index 4cc45b3c12eb22dad8e35e94a54ca3714284e716..01d6090ce64e077db307626f8857e69f50db3715 100644
--- a/dist/shared/utils.CsKOXHuy.mjs
+++ b/dist/shared/utils.CZGg_TXP.mjs
@@ -1,4 +1,4 @@
-import { P as PROOF_OF_STAKE_MIGRATION_DATE, T as TOTAL_SUPPLY, S as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, a as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, z as SUPPLY_DECAY } from './utils.CviVNm85.mjs';
+import { P as PROOF_OF_STAKE_MIGRATION_DATE, T as TOTAL_SUPPLY, S as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET, a as SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE, C as SUPPLY_DECAY } from './utils.BWNGyNU1.mjs';
 
 function powi(x, n) {
   if (n < 0) {
diff --git a/dist/shared/utils.CGhj4cNk.cjs b/dist/shared/utils.DML7ha_E.cjs
similarity index 92%
rename from dist/shared/utils.CGhj4cNk.cjs
rename to dist/shared/utils.DML7ha_E.cjs
index f4a4f54b9b4b0e973526c2f5ef705476f4e40022..06931339d2ed084fbaf219eb6a8e22ec8cafe9ce 100644
--- a/dist/shared/utils.CGhj4cNk.cjs
+++ b/dist/shared/utils.DML7ha_E.cjs
@@ -1,10 +1,12 @@
 'use strict';
 
 const TOTAL_SUPPLY = 21e14;
-const PROOF_OF_STAKE_MIGRATION_DATE = /* @__PURE__ */ new Date("2024-11-19");
+const PROOF_OF_STAKE_MIGRATION_DATE = /* @__PURE__ */ new Date("2024-11-19T16:45:20.000Z");
+const PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = /* @__PURE__ */ new Date("2024-11-13T20:00:00.000Z");
 const SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE = 1289310965406244e-5;
 const SUPPLY_AT_PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = 1203075533952899e-5;
 const PROOF_OF_STAKE_MIGRATION_BLOCK = 3456e3;
+const PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET = 3032010;
 const PROOF_OF_WORK_INITIAL_SUPPLY = 252e12;
 const PROOF_OF_WORK_EMISSION_SPEED = 4194304;
 const PROOF_OF_WORK_EMISSION_TAIL_START = 48692960;
@@ -65,7 +67,9 @@ exports.MIN_EPOCHS_STORED = MIN_EPOCHS_STORED;
 exports.MIN_PRODUCER_TIMEOUT = MIN_PRODUCER_TIMEOUT;
 exports.POS_DECAY_PER_DAY = POS_DECAY_PER_DAY;
 exports.PROOF_OF_STAKE_MIGRATION_BLOCK = PROOF_OF_STAKE_MIGRATION_BLOCK;
+exports.PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET = PROOF_OF_STAKE_MIGRATION_BLOCK_TESTNET;
 exports.PROOF_OF_STAKE_MIGRATION_DATE = PROOF_OF_STAKE_MIGRATION_DATE;
+exports.PROOF_OF_STAKE_MIGRATION_DATE_TESTNET = PROOF_OF_STAKE_MIGRATION_DATE_TESTNET;
 exports.PROOF_OF_WORK_EMISSION_SPEED = PROOF_OF_WORK_EMISSION_SPEED;
 exports.PROOF_OF_WORK_EMISSION_TAIL_REWARD = PROOF_OF_WORK_EMISSION_TAIL_REWARD;
 exports.PROOF_OF_WORK_EMISSION_TAIL_START = PROOF_OF_WORK_EMISSION_TAIL_START;
diff --git a/dist/shared/utils.C10-CJz4.cjs b/dist/shared/utils.WuzDKwXp.cjs
similarity index 94%
rename from dist/shared/utils.C10-CJz4.cjs
rename to dist/shared/utils.WuzDKwXp.cjs
index 553d22ba35e8a08bfc8219754aae8d1784695b83..46d72b9c690317401d8830040f5ed051829df856 100644
--- a/dist/shared/utils.C10-CJz4.cjs
+++ b/dist/shared/utils.WuzDKwXp.cjs
@@ -1,6 +1,6 @@
 'use strict';
 
-const constants = require('./utils.CGhj4cNk.cjs');
+const constants = require('./utils.DML7ha_E.cjs');
 
 function powi(x, n) {
   if (n < 0) {
diff --git a/dist/supply-calculator/supply-calculator.cjs b/dist/supply-calculator/supply-calculator.cjs
index 0652d06f7f90ffcc2d5e229f6367507f7037a687..74af32f4edd3cbb021c5c5953cf6c1a31361f8f1 100644
--- a/dist/supply-calculator/supply-calculator.cjs
+++ b/dist/supply-calculator/supply-calculator.cjs
@@ -1,7 +1,7 @@
 'use strict';
 
-const pos = require('../shared/utils.C10-CJz4.cjs');
-const constants = require('../shared/utils.CGhj4cNk.cjs');
+const pos = require('../shared/utils.WuzDKwXp.cjs');
+const constants = require('../shared/utils.DML7ha_E.cjs');
 
 function _powBlockRewardAt(currentSupply, blockHeight) {
   if (blockHeight <= 0) return 0;
diff --git a/dist/supply-calculator/supply-calculator.mjs b/dist/supply-calculator/supply-calculator.mjs
index 275a4554d95493b1c60c144dbec47028f3119575..66316a368054d12a6396734a8e078346b4d9753c 100644
--- a/dist/supply-calculator/supply-calculator.mjs
+++ b/dist/supply-calculator/supply-calculator.mjs
@@ -1,5 +1,5 @@
-export { p as posSupplyAt, a as powi } from '../shared/utils.CsKOXHuy.mjs';
-import { c as PROOF_OF_STAKE_MIGRATION_BLOCK, P as PROOF_OF_STAKE_MIGRATION_DATE, f as PROOF_OF_WORK_INITIAL_SUPPLY, h as PROOF_OF_WORK_EMISSION_TAIL_START, i as PROOF_OF_WORK_EMISSION_TAIL_REWARD, g as PROOF_OF_WORK_EMISSION_SPEED } from '../shared/utils.CviVNm85.mjs';
+export { p as posSupplyAt, a as powi } from '../shared/utils.CZGg_TXP.mjs';
+import { f as PROOF_OF_STAKE_MIGRATION_BLOCK, P as PROOF_OF_STAKE_MIGRATION_DATE, h as PROOF_OF_WORK_INITIAL_SUPPLY, j as PROOF_OF_WORK_EMISSION_TAIL_START, k as PROOF_OF_WORK_EMISSION_TAIL_REWARD, i as PROOF_OF_WORK_EMISSION_SPEED } from '../shared/utils.BWNGyNU1.mjs';
 
 function _powBlockRewardAt(currentSupply, blockHeight) {
   if (blockHeight <= 0) return 0;
